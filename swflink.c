/*
	SWFLink
	Du Song <freewizard@gmail.com>
	a tool to merge swf generated by MTASC

	Based on swftools by Matthias Kramm <kramm@quiss.org> 

	This program is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation; either version 2 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "../lib/rfxswf.h"
#include "../lib/args.h"
#include "../lib/log.h"
#include "../config.h"

struct config_t
{
	int mode;
	int loglevel;
};
struct config_t config;

char * main_filename = 0;
char * lib_filename[128];
int libCount = 0;
char * outputname = "output.swf";

int args_callback_option(char*name,char*val) {
	if (!strcmp(name, "o"))
	{
		outputname = val;
		return 1;
	}
	else if (!strcmp(name, "v"))
	{
		config.loglevel ++;
		return 0;
	}
	else if (!strcmp(name, "r"))
	{
		config.mode = 1;
		return 0;
	}
	else if (!strcmp(name, "V"))
	{	
		printf("swflink - $Rev$\n");
		exit(0);
	}
	else 
	{
		fprintf(stderr, "Unknown option: -%s\n", name);
		exit(1);
	}
}

static struct options_t options[] = {
	{"o", "output"},
	{"v", "verbose"},
	{"r", "replace"},
	{0,0}
};

int args_callback_longoption(char*name,char*val) {
	return args_long2shortoption(options, name, val);
}

int args_callback_command(char*name, char*val) {
	char*myname = strdup(name);
	char*filename;
	filename = strchr(myname, '=');
	if(filename) {
		*filename = 0;
		filename++;
	} else {
	// argument has no explicit name field. guess one from the file name
		char*path = strrchr(myname, '/');
		char*ext = strrchr(myname, '.');
		if(!path) path = myname;
		else path ++;
		if(ext) *ext = 0;
		myname = path;
		filename = name;
	}

	if(!main_filename) {
		main_filename = filename;
	} else {		 
		msg("<verbose> library entity %s (named \"%s\")\n", filename, myname);

		lib_filename[libCount] = filename;
		libCount ++;
	}
	return 0;
}

void args_callback_usage(char *name)
{
	printf("\n");
	printf("Usage: %s [-v] [-z] [-o output.swf] main.swf library1.swf [... libraryN.swf]\n", name);
	printf("\n");
	printf("-o , --output <outputfile>	 Explicitly specify output file. (otherwise, output.swf will be used)\n");
	printf("-v , --verbose				 Be verbose. Use more than one -v for greater effect \n");
	printf("-r , --replace				 Replace mode, will replace classes in main.swf if found in library.swf\n");
	printf("\n");
}

static char defineBitmap[65536];

static int filtered_tags_in_lib[] = 
{
	ST_SETBACKGROUNDCOLOR,
	ST_DEFINEFONTNAME,
	ST_FILEATTRIBUTES,
	ST_PROTECT,
	ST_SCRIPTLIMITS,
	ST_ENABLEDEBUGGER,
	ST_ENABLEDEBUGGER2,
	ST_DOACTION,
	ST_SHOWFRAME,
	-1
};

static char tag_allowed(int id)
{
	int t=0;
	while(filtered_tags_in_lib[t]>=0)
	{
		if(filtered_tags_in_lib[t] == id) 
			return 0;
		t++;
	}
	return 1; 
}

void do_insert(SWF*mainSwf, SWF*libSwf, SWF*newSwf)
{
	if(!mainSwf->fileVersion && libSwf)
		mainSwf->fileVersion = libSwf->fileVersion;

	mainSwf->fileAttributes |= libSwf->fileAttributes;

	swf_FoldAll(mainSwf);
	swf_FoldAll(libSwf);

	memset(defineBitmap, 0, sizeof(defineBitmap));

	char* depths;
	int t;
	TAG*tag;
	TAG*mtag,*stag;

	tag = mainSwf->firstTag;
	while(tag)
	{
		if(swf_isDefiningTag(tag)) {
			int defineid = swf_GetDefineID(tag);
			msg("<debug> [main]  tagid %02x defines object %d", tag->id, defineid);
			defineBitmap[defineid] = 1;
		}
		tag = tag->next;
	}

	swf_Relocate(libSwf, defineBitmap);

	memcpy(newSwf, mainSwf, sizeof(SWF));

	tag = newSwf->firstTag = swf_InsertTag(0, ST_REFLEX); // to be removed later

	mtag = mainSwf->firstTag;
	while(mtag && !swf_isDefiningTag(mtag) && mtag->id!=ST_END)
	{
		int num=1;
		msg("<debug> [main]  write tag %02x (%d bytes)", 
			mtag->id, mtag->len);
		tag = swf_InsertTag(tag, mtag->id);
		swf_SetBlock(tag, mtag->data, mtag->len);
		mtag = mtag->next;
	}

	stag = libSwf->firstTag;
	while(stag && stag->id!=ST_END)
	{
		if(tag_allowed(stag->id)) {
			msg("<debug> [lib]   add tag %02x (%d bytes)", 
				stag->id, stag->len);
			tag = swf_InsertTag(tag, stag->id);
			swf_SetBlock(tag, stag->data, stag->len);
		} else {
			msg("<debug> [lib]   ignore tag %02x (%d bytes)", 
				stag->id, stag->len);
		}
		stag = stag->next;	
	}

	while(mtag && mtag->id!=ST_END)
	{
		int num=1;
		msg("<debug> [main]  write tag %02x (%d bytes)", 
			mtag->id, mtag->len);
		tag = swf_InsertTag(tag, mtag->id);
		swf_SetBlock(tag, mtag->data, mtag->len);
		mtag = mtag->next;
	}

	tag = swf_InsertTag(tag, ST_END);

	swf_DeleteTag(newSwf, tag);
}

struct lookup_t
{
	U16 id;
	char* name;
	TAG* tag;
};
struct lookup_t lookup[256];
int cntLookup;
int lookup_class(char* name) {
	int i;
	for (i=0; i<cntLookup; i++) {
		if (!strcmp(name, lookup[i].name)) return i;
	}
	return -1;
}
int check_class(TAG* tag, char** name, U16* id) {
	if (tag->id==ST_DEFINESPRITE && tag->next && tag->next->id==ST_EXPORTASSETS && tag->next->next && tag->next->next->id == ST_DOINITACTION) {
		//Get id of Tag 1
		U16 idDefineSprite = swf_GetDefineID(tag);
		//Get id of Tag 2
		U16 idExportAsset = 0;
		TAG *t2 = tag->next;
		int oldTagPos = swf_GetTagPos(t2);
		swf_SetTagPos(t2,0);
		char* nameExportAsset = NULL;
		int numExportAsset = swf_GetU16(t2);
		int t;
		for(t=0;t<numExportAsset;t++){
			idExportAsset = swf_GetU16(t2);
			nameExportAsset = swf_GetString(t2);
		}
		swf_SetTagPos(t2,oldTagPos);
		//Get id of Tag 3
		U16 idDoInitAction = swf_GetDefineID(tag->next->next);
		//Check and add to symbol table
		if (idDefineSprite == idExportAsset && idExportAsset == idDoInitAction && numExportAsset) {
			if (numExportAsset > 1) msg("<error> More than one define in ExportAssets, unsupported, skip.");
			else {
				*id = idDefineSprite;
				*name = nameExportAsset;
				return TRUE;
			}
		}
	}
	return FALSE;
}
void replace_tag_id(TAG* tag, int old_id, int new_id) {
	if(swf_isDefiningTag(tag)&&swf_GetDefineID(tag)==old_id) {
		//msg("<debug> set define id %d", new_id); 
		swf_SetDefineID(tag, new_id);
	}
	int num = swf_GetNumUsedIDs(tag);
	if(num) {
		int t;
		int *ptr = (int*)rfx_alloc(sizeof(int)*num);
		swf_GetUsedIDs(tag, ptr);
		for(t=0;t<num;t++) {
			int id = GET16(&tag->data[ptr[t]]);
			if(id != old_id) {
				//msg("<debug> not replace id %d, old_id = %d", id, old_id); 
			} else {
				//msg("<debug> replace id %d => %d", id, new_id); 
				PUT16(&tag->data[ptr[t]], new_id);
			}
		}
	}
}
void do_replace(SWF*mainSwf, SWF*libSwf, SWF*newSwf)
{
	if(!mainSwf->fileVersion && libSwf)
		mainSwf->fileVersion = libSwf->fileVersion;

	mainSwf->fileAttributes |= libSwf->fileAttributes;

	swf_FoldAll(mainSwf);
	swf_FoldAll(libSwf);

	memset(lookup, 0, sizeof(lookup));

	TAG*tag;
	TAG*mtag,*stag;
	
	cntLookup = 0;
	tag = libSwf->firstTag;
	while(tag)
	{
		if (check_class(tag, &lookup[cntLookup].name, &lookup[cntLookup].id)) {
			msg("<verbose> Found class %s in library swf, id %d.", lookup[cntLookup].name, lookup[cntLookup].id);
			lookup[cntLookup].tag = tag;
			cntLookup ++ ;
			tag = tag->next->next;
		}
		tag = tag->next;
	}
	
	memcpy(newSwf, mainSwf, sizeof(SWF));

	tag = newSwf->firstTag = swf_InsertTag(0, ST_REFLEX); // to be removed later

	mtag = mainSwf->firstTag;
	while(mtag && mtag->id!=ST_END)
	{
		char* className;
		U16 classId;
		int i, j;
		if (check_class(mtag, &className, &classId) && -1!=(i=lookup_class(className))) {
			msg("<verbose> replacing class %s id %d => %d", className, lookup[i].id, classId);
			stag = lookup[i].tag;
			for (j=0;j<3;j++) {
				tag = swf_InsertTag(tag, stag->id);
				swf_SetBlock(tag, stag->data, stag->len);
				replace_tag_id(tag, lookup[i].id, classId);
				msg("<debug> replace tag %02x (%d bytes)", stag->id, stag->len);
				stag = stag->next;
			}
			mtag = mtag->next->next->next;
		} else {
			msg("<debug> add tag %02x (%d bytes)", mtag->id, mtag->len);
			tag = swf_InsertTag(tag, mtag->id);
			swf_SetBlock(tag, mtag->data, mtag->len);
			mtag = mtag->next;
		}
	}

	tag = swf_InsertTag(tag, ST_END);

	swf_DeleteTag(newSwf, newSwf->firstTag);
}

int main(int argn, char *argv[])
{
	int fi;
	SWF mainSwf;
	SWF libSwf;
	SWF newSwf;
	int t;

	config.loglevel = 2; 
	config.mode = 0;
	//no_extra_tags = 1;

	processargs(argn, argv);
	initLog(0,-1,0,0,-1,config.loglevel);

	int ret;
	msg("<notice> Loading %s", main_filename);
	fi = open(main_filename, O_RDONLY|O_BINARY);
	if(fi<0) {
		msg("<fatal> Failed to open %s", main_filename);
		exit(1);
	}
	ret = swf_ReadSWF(fi, &mainSwf);
	if(ret<0) {
		msg("<fatal> Failed to read from %s", main_filename);
		exit(1);
	}

	msg("<debug> Read %d bytes from %s.", ret, main_filename);
	close(fi);

	if (!libCount)
	{
		msg("<error> You must have at least one library.");
		return 0;
	}
	t = libCount;
	{
		t--;
		msg("<notice> Processing %s", lib_filename[t]);
		int ret;
		fi = open(lib_filename[t], O_RDONLY|O_BINARY);
		if(!fi) {
			msg("<fatal> Failed to open %s\n", lib_filename[t]);
			exit(1);
		}
		ret = swf_ReadSWF(fi, &libSwf);
		if(ret<0) {
			msg("<fatal> Failed to read from %s\n", lib_filename[t]);
			exit(1);
		}
		msg("<debug> Read %d bytes from libSwf file %s\n", ret, lib_filename[t]);
		close(fi);
		if (config.mode==0) do_insert(&mainSwf, &libSwf, &newSwf);
		else if (config.mode==1) do_replace(&mainSwf, &libSwf, &newSwf);
		mainSwf = newSwf;
	} while (t>0);

	if(!newSwf.fileVersion)
		newSwf.fileVersion = 4;

	msg("<notice> Writing into %s", outputname);
	fi = open(outputname, O_BINARY|O_RDWR|O_TRUNC|O_CREAT, 0666);

	if(1) { // force zlib
		if(newSwf.fileVersion < 6)
			newSwf.fileVersion = 6;
		newSwf.compressed = 1;
		swf_WriteSWF(fi, &newSwf);
	} else {
		newSwf.compressed = -1; // don't compress
		swf_WriteSWF(fi, &newSwf);
	}
	close(fi);
	return 0;
}
